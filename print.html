<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DiffSL</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DiffSL</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="diffsl-language"><a class="header" href="#diffsl-language">DiffSL Language</a></h1>
<p>The DSL is designed to be an easy and flexible language for specifying
ODE systems and is based on the idea that a ODE system can be specified by a set
of equations of the form:</p>
<p>$$
M(t) \frac{\mathrm{d}\mathbf{u}}{\mathrm{d}t} = F(\mathbf{u}, t)
$$</p>
<p>where \( \mathbf{u} \) is the vector of state variables and \( t \) is the time. The DSL
allows the user to specify the state vector \( \mathbf{u} \) and the RHS function \( F \).
Optionally, the user can also define the derivative of the state vector \( \mathrm{d}\mathbf{u}/\mathrm{d}t \)
and the mass matrix \( M \) as a function of \( \mathrm{d}\mathbf{u}/\mathrm{d}t \) (note that this function should be linear!).</p>
<p>The user is also free to define an an arbitrary number of intermediate
scalars and vectors of the users that are required to calculate \( F \) and \( M \).</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h2>
<p>To illustrate the language, consider the following simple example of a logistic growth model:</p>
<p>$$
\frac{\mathrm{d}N}{\mathrm{d}t} = r N (1 - N/K)
$$</p>
<p>where \( N \) is the population, \( r \) is the growth rate, and \( K \) is the carrying capacity.</p>
<p>To specify this model in DiffSL, we can write:</p>
<pre><code>in = [r, k]
u_i {
  N = 0.0
}
F_i {
  r * N * (1 - N/k)
}
out_i {
  N
}
</code></pre>
<p>Here, we define the input parameters for our model as a vector <code>in</code> with the growth rate <code>r</code> and the carrying capacity <code>k</code>. We then define the state vector <code>u_i</code> with the population <code>N</code> initialized to <code>0.0</code>. Next, we define the RHS function <code>F_i</code> as the logistic growth equation. Finally, we define the output vector <code>out_i</code> with the population <code>N</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-tensor-variables"><a class="header" href="#defining-tensor-variables">Defining tensor variables</a></h1>
<p>The DiffSL language only has a single type of variable, which is a n-dimensional tensor filled with double precision floating point numbers.
These tensors can be dense, sparse or diagonal, and the compiler will try to choose the representation that is most efficient, preferring diagonal and then sparse matrices over dense.</p>
<p>The simplest tensor is a 0th dimensional scalar. For example, to define a scalar variable \( k \) with value 1.0, we write:</p>
<pre><code>k { 1.0 }
</code></pre>
<p>Here <code>k</code> is the <em>label</em> for the tensor, which we can later use to refer to it in expressions. In the curly brackets we have one or more <em>elements</em> of the tensor,
and here <code>k</code> only has a single element, which is a constant value 1.</p>
<p>Lets now define a 1-dimensional vector variable \( \mathbf{v} \) with 3 elements:</p>
<pre><code>v_i {
 1.0,
 2.0,
 3.0,
}
</code></pre>
<p>The list of elements within a tensor are deliniated with a comma <code>,</code> and the trailing comma at the end of the list is optional.
Whitespace is ignored so you can also write this tensor all on the one line:</p>
<pre><code>v_i { 1.0, 2.0, 3.0 }
</code></pre>
<h2 id="subscripts"><a class="header" href="#subscripts">Subscripts</a></h2>
<p>In the previous vector <code>v_i</code>, the subscript <code>_i</code> indicates that this is a 1D vector. Each subscript is a single character,
and the number of subscripts indicates the number of dimensions of the tensor. You can use any character for the subscript,</p>
<pre><code>v_x { 1.0, 2.0, 3.0 }
w_a { 2.0, 3.0 }
v_i { 1.0, 2.0, 3.0, 4.0 }
</code></pre>
<h2 id="ranges"><a class="header" href="#ranges">Ranges</a></h2>
<p>Each element of a tensor can optionally give a <em>range</em> of index numbers, which is used by the compiler to determine the extent of each element.
This is useful when defining higher dimensional tensors, such as matrices. For example, to define a 2x3 matrix \( A \) with all elements set to <code>1.0</code>, we write:</p>
<pre><code>A_ij {
 (0:2, 0:3) = 1.0,
}
</code></pre>
<p>Note the two subscript to indicate that this is a 2D tensor. The size of the
single element is given in the brackets, we have two ranges <code>0:2</code> and <code>0:3</code> that correspond to the two dimensions of the matrix.</p>
<p>Here is another example of a 4x2 matrix \( B \) with rows 0 to 2 set to <code>1.0</code> and rows 3 to 4 set to <code>2.0</code>:</p>
<pre><code>A_ij {
 (0:2, 0:3) = 1.0,
 (3:4, 0:3) = 2.0,
}
</code></pre>
<p>For specifying a single index, you can simply write the index number without the colon, for example to define a 3x3 identity matrix $I$:</p>
<pre><code>I_ij {
 (0, 0) = 1.0,
 (1, 1) = 1.0,
 (2, 2) = 1.0,
}
</code></pre>
<p>Note that the compiler will automatically infer the size of the tensor from the ranges you provide, so you don't need to specify the size of the tensor explicitly.
Since the maximum index in the range is 2, the compiler will infer that the size of the tensor is 3x3.</p>
<p>Notice also that we have not defined all the elements of the matrix, only the non-zero elements. The compiler will assume that all other elements are zero.</p>
<p>Finally, you can also use the <code>..</code> operator to specify a <em>diagonal</em> range of indices. For example, to define a 3x3 matrix \( D \) with the diagonal elements set to <code>1.0</code>:</p>
<pre><code>D_ij {
 (0..2, 0..2) = 1.0,
}
</code></pre>
<h2 id="sparse-and-diagonal-matrices"><a class="header" href="#sparse-and-diagonal-matrices">Sparse and diagonal matrices</a></h2>
<p>We can automatically define a sparse matrix \( B \) by simply specifying the non-zero elements:</p>
<pre><code>B_ij {
 (0, 0) = 1.0,
 (0, 1) = 2.0,
 (1, 1) = 3.0,
}
</code></pre>
<p>The compiler will infer that this is a 2x2 matrix, and will automatically represent it as a sparse matrix.
We can force the compiler to use a dense representation by specifying the zeros explicitly:</p>
<pre><code>B_ij {
 (0, 0) = 1.0,
 (0, 1) = 2.0,
 (1, 0) = 0.0,
 (1, 1) = 3.0,
}
</code></pre>
<p>As well as specifying a sparse matrix, we can also define a diagonal matrix by specifying the diagonal elements:</p>
<pre><code>D_ij {
 (0, 0) = 1.0,
 (1, 1) = 2.0,
 (2, 2) = 3.0,
}
</code></pre>
<p>The compiler will infer that this is a 3x3 matrix, and will automatically represent it as a diagonal matrix.</p>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Each element of a tensor can optionally be given a name or <em>label</em> that can be used to refer to the element in expressions.</p>
<p>For example, to define a vector with two named elements:</p>
<pre><code>v_i {
 x = 1.0,
 y = 2.0,
}
</code></pre>
<p>Here we have defined a single tensor <code>v_i</code> with two named elements <code>x</code> and <code>y</code>. We can then refer to the individual elements in expressions, where they will act as if they were separate variables:</p>
<pre><code>v_i { x = 1.0, y = 2.0 }
w_i { 2 * y, 3 * x }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensor-operations"><a class="header" href="#tensor-operations">Tensor Operations</a></h1>
<p>We can use standard algebraic operations on variables. To refer to previously
defined variables, we use the variable name, making sure to use the correct
subscript if it is a vector or tensor.</p>
<p>For example, to define a scalar variable \( a \) as the sum of two other scalar
variables \( b \) and \( c \), we write:</p>
<pre><code>b { 1.0 }
c { 2.0 }
a { b + c }
</code></pre>
<p>The scalar <code>a</code> will therefore be equal to 3.0.</p>
<p>To define a vector variable \( \mathbf{v} \) as the sum of two other vector
variables \( \mathbf{u} \) and \( \mathbf{w} \), we write:</p>
<pre><code>u_i { 1.0, 2.0 }
w_i { 3.0, 4.0 }
v_i { u_i + w_i }
</code></pre>
<p>Notice that the index of the vectors within the expression must match the index of the output vector <code>v_i</code>.
So if we defined <code>v_a</code> instead of <code>v_i</code>, the expression would be:</p>
<pre><code>v_a { u_a + w_a }
</code></pre>
<h2 id="translations"><a class="header" href="#translations">Translations</a></h2>
<p>For higher-dimensional tensors, the order of the indices in the expression relative to the output tensor is important.</p>
<p>For example, we can use the indices to define a translation of a matrix. Here we define a new matrix \( C \) that is the sum of \( A \) and \( B^T \)$,
where \( B^T \) is the transpose of \( B \)</p>
<pre><code>C_ij { A_ij + B_ji }
</code></pre>
<p>Notice that the indices of \( B^T \) are reversed in the expression compared to the output tensor \( C \), indicating that we are indexing the rows of \( B \) with <code>j</code> and the columns with <code>i</code> when we calculate the <code>(i, j)</code> element of \( C \).</p>
<h2 id="broadcasting"><a class="header" href="#broadcasting">Broadcasting</a></h2>
<p>Broadcasting is supported in the language, so you can perform element-wise operations on tensors of different shapes. For example, the following will define a new vector \( \mathbf{d} \) that is the sum of \( \mathbf{a} \) and a scalar \( k \):</p>
<pre><code>a_i { 1.0, 2.0 }
k { 3.0 }
d_i { a_i + k }
</code></pre>
<p>Here the scalar \( k \) is broadcast to the same shape as \( \mathbf{a} \) before the addition. The output vector \( \mathbf{d} \) will be \( [4.0, 5.0] \).</p>
<p>DiffSL uses the same broadcasting rules as NumPy, and you can read more about this in the <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">NumPy documentation</a>.</p>
<h2 id="contractions"><a class="header" href="#contractions">Contractions</a></h2>
<p>The DiffSL indexing notation allows for tensor contractions, which are operations that sum over one or more indices.
The rule used is that any indices that do not appear in the output tensor will be summed over.</p>
<p>For example, the following defines a new vector \( \mathbf{v} \) that is the sum of the rows of a matrix \( A \):</p>
<pre><code>v_i { A_ij }
</code></pre>
<p>Another example, the following will define a new scalar \( s \) that is the sum of the element-wise product of two vectors \( \mathbf{u} \) and \( \mathbf{v} \) (i.e. an inner product):</p>
<pre><code>u_i { 1.0, 2.0 }
v_i { 3.0, 4.0 }
s { u_i * v_i }
</code></pre>
<p>Here the <code>i</code> index is summed over, so the scalar <code>s</code> is the sum of the element-wise product of the two vectors <code>u</code> and <code>v</code>.</p>
<p>We can also define a matrix-vector multiplication, the following will define a new vector \( \mathbf{v} \) that is
the result of a matrix-vector multiplication of a matrix \( A \) and a vector \( \mathbf{u} \):</p>
<pre><code>v_i { A_ij * u_j }
</code></pre>
<p>This operation is actually a combination of a broadcast <code>A_ij * u_j</code>, followed by a contraction over the <code>j</code> index,
the <code>A_ij * u_j</code> expression broadcasts the vector <code>u</code> to the same shape as <code>A</code>, forming a new 2D tensor, and
the output vector <code>v_i</code> implicitly sums over the missing <code>j</code> index to form the final output vector.
To illustrate this further, lets manually break this matrix-vector multiplication into two steps using an intermediary tensor <code>M_ij</code>:</p>
<pre><code>M_ij { A_ij * u_j }
v_i { M_ij }
</code></pre>
<p>The first step calculates the element-wise product of <code>A</code> and <code>u</code> using broadcasting into the 2D tensor <code>M</code>, and the second step uses a contraction to sum over the <code>j</code> index to form the output vector <code>v</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-system-of-odes"><a class="header" href="#defining-a-system-of-odes">Defining a system of ODEs</a></h1>
<p>The primary goal of the DiffSL language is to define a system of ODEs in the following form:</p>
<p>$$
\begin{align*}
M(t) \frac{\mathrm{d}\mathbf{u}}{\mathrm{d}t} &amp;= F(\mathbf{u}, t) \\
\mathbf{u}(0) &amp;= \mathbf{u}_0
\end{align*}
$$</p>
<p>where \( \mathbf{u} \) is the vector of state variables, \( \mathbf{u}_0 \) is the initial condition, \( F \) is the RHS function, and \( M \) is the mass matrix.
The DSL allows the user to specify the state vector \( \mathbf{u} \) and the RHS function \( F \).</p>
<p>Optionally, the user can also define the derivative of the state vector \( \mathrm{d}\mathbf{u}/\mathrm{d}t \) and the mass matrix \( M \) as a function of \( \mathrm{d}\mathbf{u}/\mathrm{d}t \)
(note that this function should be linear!).
The user is also free to define an arbitrary number of intermediate tensors that are required to calculate \( F \) and \( M \).</p>
<h2 id="defining-state-variables"><a class="header" href="#defining-state-variables">Defining state variables</a></h2>
<p>To define the state variables \(\mathbf{u} \), we create a special
vector variable <code>u_i</code>. Note the particular name <code>u</code> is used to indicate that this
is the state vector.</p>
<p>The values that we use for <code>u_i</code> are the initial values of the state variables
at \( t=0 \), so an initial condition \( \mathbf{u}(t=0) = [x(0), y(0), z(0)] = [1, 0, 0] \) is defined as:</p>
<pre><code>u_i {
  x = 1,
  y = 0,
  z = 0,
}
</code></pre>
<p>Since we will often use the individual elements of the state vector in the RHS function, it is useful to define them as separate variables as well.</p>
<p>We can optionally define the time derivatives of the state variables,
\( \mathbf{\dot{u}} \) as well:</p>
<pre><code>dudt_i {
  dxdt = 1,
  dydt = 0,
  dzdt = 0,
}
</code></pre>
<p>Here the initial values of the time derivatives are given.
In many cases any values can be given here as the time derivatives of the state variables are calculated from the RHS.
However, if there are any algebraic variables in the equations then these values can be used
used as a starting point to calculate a set of consistent initial values for the
state variables.</p>
<p>Note that there is no need to define <code>dudt</code> if you do not define a mass matrix \( M \).</p>
<h2 id="defining-the-ode-system-equations"><a class="header" href="#defining-the-ode-system-equations">Defining the ODE system equations</a></h2>
<p>We now define the right-hand-side  function \( F \) that we want to solve, using the
variables that we have defined earlier. We do this by defining a vector variable
<code>F_i</code> that corresponds to the RHS of the equations.</p>
<p>For example, to define a simple system of ODEs:</p>
<p>$$
\begin{align*}
\frac{dx}{dt} &amp;= y \\
\frac{dy}{dt} &amp;= -x \\
x(0) &amp;= 1 \\
y(0) &amp;= 0 \\
\end{align*}
$$</p>
<p>We write:</p>
<pre><code>u_i { x = 1, y = 0 }
F_i { y, -x }
</code></pre>
<h2 id="defining-the-mass-matrix"><a class="header" href="#defining-the-mass-matrix">Defining the mass matrix</a></h2>
<p>We can also define a mass matrix \( M \) by defining a vector variable <code>M_i</code> which is the product of the mass matrix with the time derivative of the state vector \( M \mathbf{\dot{u}} \).
This is optional, and if not defined, the mass matrix is assumed to be the identity
matrix.</p>
<p>Notice that we are defining a vector variable <code>M_i</code>, which is the LHS of the ODE equations \( M \mathbf{\dot{u}} \), and <strong>not</strong> the mass matrix itself.</p>
<p>For example, lets define a simple DAE system using a singular mass matrix with a
zero on the diagonal:</p>
<p>$$
\begin{align*}
\frac{\mathrm{d}x}{\mathrm{d}t} &amp;= x \\
0 &amp;= y-x \\
x(0) &amp;= 1 \\
y(0) &amp;= 0 \\
\end{align*}
$$</p>
<p>We write:</p>
<pre><code>u_i {
 x = 1,
 y = 0,
}
dudt_i {
 dxdt = 0,
 dydt = 1,
}
M_i {
 dxdt,
 0,
}
F_i {
 x,
 y-x,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inputs--outputs"><a class="header" href="#inputs--outputs">Inputs &amp; Outputs</a></h1>
<p>Often it is useful to parameterize the system of equations using a set of input parameters. It is also useful to be able to extract certain variables from the system for further analysis.
In this section we will show how to specify inputs and outputs in the DiffSL language.</p>
<h2 id="specifying-inputs"><a class="header" href="#specifying-inputs">Specifying inputs</a></h2>
<p>We can override the values of any scalar variables by specifying them as input
variables.  To do this, we add a line at the top of the code to specify that
these are input variables:</p>
<pre><code>in = [k]
k { 1.0 }
u { 0.1 }
F { k * u }
</code></pre>
<p>Here we have specified a single input parameter <code>k</code> that is used in the RHS function <code>F</code>.
The value of <code>k</code> is set to <code>1.0</code> in the code, but this value is only a default, and can be overridden by passing in a value at solve time.</p>
<p>We can use input parameters anywhere in the code, including in the definition of other input parameters.</p>
<pre><code>in = [k]
k { 1.0 }
g { 2 * k }
F { g * u }
</code></pre>
<p>or in the intial conditions of the state variables:</p>
<pre><code>in = [k]
k { 1.0 }
u_i {
  x = k,
}
F { u }
</code></pre>
<h2 id="specifying-outputs"><a class="header" href="#specifying-outputs">Specifying outputs</a></h2>
<p>We can also specify the outputs of the system. These might be the state
variables themselves, or they might be other variables that are calculated from
the state variables.</p>
<p>Here is an example where we simply output the elements of the state vector:</p>
<pre><code>u_i {
  x = 1.0,
  y = 2.0,
  z = 3.0,
}
out_i { x, y, z }
</code></pre>
<p>or we can derive additional outputs from the state variables:</p>
<pre><code>u_i {
  x = 1.0,
  y = 2.0,
  z = 3.0,
}
out { x + y + z }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-defined-functions"><a class="header" href="#pre-defined-functions">Pre-defined functions</a></h1>
<p>The DiffSL supports the following mathematical functions that can be used in an expression:</p>
<ul>
<li><code>pow(x, y)</code> - x raised to the power of y</li>
<li><code>sin(x)</code> - sine of x</li>
<li><code>cos(x)</code> - cosine of x</li>
<li><code>tan(x)</code> - tangent of x</li>
<li><code>exp(x)</code> - exponential of x</li>
<li><code>log(x)</code> - natural logarithm of x</li>
<li><code>sqrt(x)</code> - square root of x</li>
<li><code>abs(x)</code> - absolute value of x</li>
<li><code>sigmoid(x)</code> - sigmoid function of x</li>
<li><code>heaviside(x)</code> - Heaviside step function of x</li>
</ul>
<p>You can use these functions as part of an expression in the DSL. For example, to define a variable <code>a</code> that is the sine of another variable <code>b</code>, you can write:</p>
<pre><code>b { 1.0 }
a { sin(b) }
</code></pre>
<h1 id="pre-defined-variables"><a class="header" href="#pre-defined-variables">Pre-defined variables</a></h1>
<p>The only predefined variable is the scalar <code>t</code> which is the current time, this allows the equations to be written as functions of time. For example</p>
<pre><code>F_i {
  t + sin(t)
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
